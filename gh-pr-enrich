#!/bin/bash
# gh-pr-enrich - GitHub CLI extension for comprehensive PR analysis
# Fetches PR details, comments, and optionally enriches with Claude AI analysis.
#
# Installation:
#   gh extension install bl4ck3lk/gh-pr-enrich
#
# Usage:
#   gh pr-enrich <PR_NUMBER> [--json] [--markdown] [--output-dir <DIR>] [--enrich] [--diff]
#   gh pr-enrich resolve <THREAD_ID> [THREAD_ID...]
#   gh pr-enrich watch <PR_NUMBER> [--interval MIN] [--enrich] [--notify]
#   gh pr-enrich address <PR_NUMBER>
#   gh pr-enrich install-skill | uninstall-skill
#
# Examples:
#   gh pr-enrich 123                    # Fetch PR details
#   gh pr-enrich 123 --enrich           # Fetch + Claude analysis
#   gh pr-enrich 123 --enrich --diff    # Analysis with code context
#   gh pr-enrich 123 --json             # Output JSON only
#   gh pr-enrich resolve PRRT_xxx       # Resolve a comment thread
#   gh pr-enrich watch 123 --enrich     # Monitor PR for changes
#   gh pr-enrich address 123            # Interactive issue fixing

set -e

VERSION="1.0.0"

# Handle --version flag
if [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
    echo "gh-pr-enrich version $VERSION"
    exit 0
fi

# Cross-platform path canonicalization (works on both BSD/macOS and GNU/Linux)
# Returns absolute path, resolving symlinks
canonicalize_path() {
    local path="$1"
    if [ -d "$path" ]; then
        (cd "$path" && pwd -P)
    elif [ -L "$path" ]; then
        local target
        target=$(readlink "$path")
        if [[ "$target" = /* ]]; then
            # Absolute symlink target
            canonicalize_path "$target"
        else
            # Relative symlink target - resolve from symlink's directory
            local dir
            dir=$(dirname "$path")
            canonicalize_path "$dir/$target"
        fi
    elif [ -f "$path" ]; then
        local dir
        dir=$(cd "$(dirname "$path")" && pwd -P)
        echo "$dir/$(basename "$path")"
    else
        # Path doesn't exist, just normalize it
        echo "$path"
    fi
}

# Handle install-skill subcommand
if [ "$1" = "install-skill" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
    SKILL_SOURCE="$SCRIPT_DIR/.claude/skills/gh-pr-enrich"
    SKILL_TARGET="$HOME/.claude/skills/gh-pr-enrich"
    SKILLS_DIR="$HOME/.claude/skills"

    # Check if skill exists in extension
    if [ ! -d "$SKILL_SOURCE" ]; then
        echo "Error: Skill not found at $SKILL_SOURCE"
        echo "Try upgrading the extension: gh extension upgrade pr-enrich"
        exit 1
    fi

    # Pre-flight validation: Check ~/.claude/skills path
    if [ -f "$SKILLS_DIR" ]; then
        echo "Error: $SKILLS_DIR exists as a regular file, not a directory."
        echo "Remove it first: rm $SKILLS_DIR"
        exit 1
    fi

    # Create skills directory if needed
    if [ ! -d "$SKILLS_DIR" ]; then
        if ! mkdir -p "$SKILLS_DIR" 2>/dev/null; then
            echo "Error: Could not create directory $SKILLS_DIR"
            echo "Check permissions on $HOME/.claude"
            exit 1
        fi
    fi

    # Pre-flight validation: Check target path
    if [ -f "$SKILL_TARGET" ] && [ ! -L "$SKILL_TARGET" ]; then
        echo "Error: $SKILL_TARGET exists as a regular file, not a symlink."
        echo "Remove it first: rm $SKILL_TARGET"
        exit 1
    fi

    # Check if already installed (with proper path canonicalization)
    if [ -L "$SKILL_TARGET" ]; then
        CURRENT_CANONICAL=$(canonicalize_path "$SKILL_TARGET")
        SOURCE_CANONICAL=$(canonicalize_path "$SKILL_SOURCE")
        if [ "$CURRENT_CANONICAL" = "$SOURCE_CANONICAL" ]; then
            echo "‚úÖ Skill already installed at $SKILL_TARGET"
            exit 0
        else
            echo "‚ö†Ô∏è  Existing symlink points to: $(readlink "$SKILL_TARGET")"
            echo "   Updating to: $SKILL_SOURCE"
            rm "$SKILL_TARGET"
        fi
    elif [ -d "$SKILL_TARGET" ]; then
        echo "Error: Directory already exists at $SKILL_TARGET"
        echo "Remove it first if you want to install the symlinked skill:"
        echo "  rm -rf $SKILL_TARGET"
        exit 1
    fi

    # Create symlink
    if ! ln -s "$SKILL_SOURCE" "$SKILL_TARGET" 2>/dev/null; then
        echo "Error: Could not create symlink at $SKILL_TARGET"
        echo "Check permissions on $SKILLS_DIR"
        exit 1
    fi
    echo "‚úÖ Claude skill installed!"
    echo "   Source: $SKILL_SOURCE"
    echo "   Target: $SKILL_TARGET"
    echo ""
    echo "The skill will auto-update when you run: gh extension upgrade pr-enrich"
    exit 0
fi

# Handle uninstall-skill subcommand
if [ "$1" = "uninstall-skill" ]; then
    SKILL_TARGET="$HOME/.claude/skills/gh-pr-enrich"

    if [ -L "$SKILL_TARGET" ]; then
        if ! rm "$SKILL_TARGET" 2>/dev/null; then
            echo "Error: Could not remove symlink at $SKILL_TARGET"
            echo "Check permissions"
            exit 1
        fi
        echo "‚úÖ Claude skill uninstalled"
    elif [ -d "$SKILL_TARGET" ]; then
        echo "‚ö†Ô∏è  $SKILL_TARGET is a directory, not a symlink"
        echo "   Remove manually if desired: rm -rf $SKILL_TARGET"
        exit 1
    elif [ -f "$SKILL_TARGET" ]; then
        echo "‚ö†Ô∏è  $SKILL_TARGET is a regular file, not a symlink"
        echo "   Remove manually if desired: rm $SKILL_TARGET"
        exit 1
    else
        echo "‚ÑπÔ∏è  Skill not installed at $SKILL_TARGET"
    fi
    exit 0
fi

# Handle resolve subcommand - resolve PR review threads by ID
if [ "$1" = "resolve" ]; then
    shift
    if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: gh pr-enrich resolve <THREAD_ID> [THREAD_ID...]"
        echo ""
        echo "Resolve one or more PR review threads by their GraphQL ID."
        echo "Thread IDs start with 'PRRT_' and can be found in:"
        echo "  - claude-analysis.json (task_list[].thread_ids)"
        echo "  - comment-threads.json"
        echo ""
        echo "Example:"
        echo "  gh pr-enrich resolve PRRT_kwDORDoRf85rizQq PRRT_kwDORDoRf85rizQ3"
        exit 0
    fi

    RESOLVED=0
    FAILED=0

    for THREAD_ID in "$@"; do
        # Validate thread ID format (PRRT_ prefix + base64-safe characters)
        if [[ ! "$THREAD_ID" =~ ^PRRT_[A-Za-z0-9_-]+$ ]]; then
            echo "‚ö†Ô∏è  Skipping invalid thread ID: $THREAD_ID (must start with PRRT_ followed by valid characters)"
            ((FAILED++))
            continue
        fi

        # Resolve the thread via GraphQL (using parameterized query to prevent injection)
        RESULT=$(gh api graphql \
            -F threadId="$THREAD_ID" \
            -f query='mutation($threadId: ID!) {
                resolveReviewThread(input: {threadId: $threadId}) {
                    thread { isResolved id }
                }
            }' 2>&1)

        if echo "$RESULT" | jq -e '.data.resolveReviewThread.thread.isResolved' > /dev/null 2>&1; then
            echo "‚úÖ Resolved: $THREAD_ID"
            ((RESOLVED++))
        else
            ERROR=$(echo "$RESULT" | jq -r '.errors[0].message // "Unknown error"' 2>/dev/null || echo "$RESULT")
            echo "‚ùå Failed to resolve $THREAD_ID: $ERROR"
            ((FAILED++))
        fi
    done

    echo ""
    echo "Summary: $RESOLVED resolved, $FAILED failed"
    exit 0
fi

# Handle watch subcommand - monitor PR for new comments
if [ "$1" = "watch" ]; then
    shift
    if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: gh pr-enrich watch <PR_NUMBER> [OPTIONS]"
        echo ""
        echo "Monitor a PR for new comments and optionally run analysis."
        echo ""
        echo "Options:"
        echo "  --interval MIN   Check interval in minutes (default: 5)"
        echo "  --enrich         Run Claude analysis when new comments found"
        echo "  --notify         Show desktop notification (macOS only)"
        echo ""
        echo "Example:"
        echo "  gh pr-enrich watch 123 --interval 2 --enrich"
        echo ""
        echo "Press Ctrl+C to stop watching."
        exit 0
    fi

    WATCH_PR="$1"
    shift

    # Validate PR number
    if ! [[ "$WATCH_PR" =~ ^[0-9]+$ ]]; then
        echo "Error: PR number must be a positive integer"
        exit 1
    fi

    WATCH_INTERVAL=5
    WATCH_ENRICH=false
    WATCH_NOTIFY=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --interval)
                if [ -z "${2:-}" ]; then
                    echo "Error: --interval requires a numeric value"
                    exit 1
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]] || [ "$2" -lt 1 ]; then
                    echo "Error: --interval must be a positive integer (got: '$2')"
                    exit 1
                fi
                WATCH_INTERVAL="$2"
                shift 2
                ;;
            --enrich)
                WATCH_ENRICH=true
                shift
                ;;
            --notify)
                WATCH_NOTIFY=true
                shift
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done

    # Validate repository access
    REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null)
    if [ -z "$REPO" ]; then
        echo "Error: Could not determine repository. Are you in a git repo with a GitHub remote?"
        exit 1
    fi

    # Verify PR exists before starting watch loop
    if ! gh pr view "$WATCH_PR" --json number > /dev/null 2>&1; then
        echo "Error: PR #$WATCH_PR not found in $REPO"
        echo "Verify the PR number and that you have access to the repository."
        exit 1
    fi

    echo "üëÄ Watching PR #$WATCH_PR in $REPO"
    echo "   Checking every $WATCH_INTERVAL minute(s)"
    echo "   Enrich: $WATCH_ENRICH | Notify: $WATCH_NOTIFY"
    echo "   Press Ctrl+C to stop"
    echo ""

    # Split repo into owner and name for parameterized queries
    REPO_OWNER="${REPO%/*}"
    REPO_NAME="${REPO#*/}"

    # Get initial comment count
    LAST_COUNT=$(gh pr view "$WATCH_PR" --json comments,reviews --jq '(.comments | length) + (.reviews | length)' 2>/dev/null || echo "0")
    # Note: Limited to 100 review threads. PRs with more threads may show incomplete counts.
    LAST_UNRESOLVED=$(gh api graphql \
        -F owner="$REPO_OWNER" \
        -F name="$REPO_NAME" \
        -F prNumber="$WATCH_PR" \
        -f query='query($owner: String!, $name: String!, $prNumber: Int!) {
            repository(owner: $owner, name: $name) {
                pullRequest(number: $prNumber) {
                    reviewThreads(first: 100) {
                        nodes { isResolved }
                    }
                }
            }
        }' --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length' 2>/dev/null || echo "0")

    echo "üìä Initial state: $LAST_COUNT comments/reviews, $LAST_UNRESOLVED unresolved threads"
    echo ""

    CONSECUTIVE_FAILURES=0
    MAX_FAILURES=3

    while true; do
        sleep $((WATCH_INTERVAL * 60))

        # Get current counts (using parameterized queries to prevent injection)
        CURRENT_COUNT=$(gh pr view "$WATCH_PR" --json comments,reviews --jq '(.comments | length) + (.reviews | length)' 2>/dev/null)
        CURRENT_UNRESOLVED=$(gh api graphql \
            -F owner="$REPO_OWNER" \
            -F name="$REPO_NAME" \
            -F prNumber="$WATCH_PR" \
            -f query='query($owner: String!, $name: String!, $prNumber: Int!) {
                repository(owner: $owner, name: $name) {
                    pullRequest(number: $prNumber) {
                        reviewThreads(first: 100) {
                            nodes { isResolved }
                        }
                    }
                }
            }' --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length' 2>/dev/null)

        TIMESTAMP=$(date '+%H:%M:%S')

        # Check for API failures
        if [ -z "$CURRENT_COUNT" ] || [ -z "$CURRENT_UNRESOLVED" ]; then
            ((CONSECUTIVE_FAILURES++))
            echo "[$TIMESTAMP] ‚ö†Ô∏è  API request failed (attempt $CONSECUTIVE_FAILURES/$MAX_FAILURES)"
            if [ "$CONSECUTIVE_FAILURES" -ge "$MAX_FAILURES" ]; then
                echo "[$TIMESTAMP] ‚ùå Too many consecutive failures. Check network/auth and restart watch."
                exit 1
            fi
            continue
        fi
        CONSECUTIVE_FAILURES=0

        if [ "$CURRENT_COUNT" -ne "$LAST_COUNT" ] || [ "$CURRENT_UNRESOLVED" -ne "$LAST_UNRESOLVED" ]; then
            NEW_COMMENTS=$((CURRENT_COUNT - LAST_COUNT))
            THREAD_DIFF=$((CURRENT_UNRESOLVED - LAST_UNRESOLVED))

            echo "[$TIMESTAMP] üîî Changes detected!"
            [ "$NEW_COMMENTS" -ne 0 ] && echo "   New comments/reviews: $NEW_COMMENTS"
            [ "$THREAD_DIFF" -gt 0 ] && echo "   New unresolved threads: +$THREAD_DIFF"
            [ "$THREAD_DIFF" -lt 0 ] && echo "   Threads resolved: ${THREAD_DIFF#-}"

            # Desktop notification (macOS)
            if [ "$WATCH_NOTIFY" = true ] && command -v osascript &> /dev/null; then
                osascript -e "display notification \"${NEW_COMMENTS} new comments, ${CURRENT_UNRESOLVED} unresolved\" with title \"PR #${WATCH_PR} Updated\"" 2>/dev/null || true
            fi

            # Run enrichment if requested
            if [ "$WATCH_ENRICH" = true ] && [ "$CURRENT_UNRESOLVED" -gt 0 ]; then
                echo "   Running analysis..."
                if "$0" "$WATCH_PR" --enrich --output-dir ".reports/pr-reviews/pr-$WATCH_PR" > /dev/null 2>&1; then
                    if [ -f ".reports/pr-reviews/pr-$WATCH_PR/claude-analysis.md" ]; then
                        echo "   ‚úÖ Analysis updated: .reports/pr-reviews/pr-$WATCH_PR/claude-analysis.md"
                    else
                        echo "   ‚ö†Ô∏è  Analysis ran but no claude-analysis.md created (no unresolved threads or Claude unavailable)"
                    fi
                else
                    echo "   ‚ùå Analysis failed - check manually with: gh pr-enrich $WATCH_PR --enrich"
                fi
            fi

            LAST_COUNT=$CURRENT_COUNT
            LAST_UNRESOLVED=$CURRENT_UNRESOLVED
            echo ""
        else
            echo "[$TIMESTAMP] No changes (comments: $CURRENT_COUNT, unresolved: $CURRENT_UNRESOLVED)"
        fi
    done
fi

# Handle address subcommand - interactive mode to work through issues
if [ "$1" = "address" ]; then
    shift
    if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: gh pr-enrich address <PR_NUMBER>"
        echo ""
        echo "Interactive mode to work through PR review issues one by one."
        echo "Shows each task from Claude analysis and lets you mark as fixed."
        echo ""
        echo "Requires: Previous 'gh pr-enrich <PR> --enrich' run"
        echo ""
        echo "Controls:"
        echo "  f - Mark as fixed (resolves thread)"
        echo "  s - Skip to next task"
        echo "  o - Open thread in browser"
        echo "  q - Quit"
        exit 0
    fi

    ADDRESS_PR="$1"
    if ! [[ "$ADDRESS_PR" =~ ^[0-9]+$ ]]; then
        echo "Error: PR number must be a positive integer"
        exit 1
    fi

    ANALYSIS_FILE=".reports/pr-reviews/pr-$ADDRESS_PR/claude-analysis.json"

    if [ ! -f "$ANALYSIS_FILE" ]; then
        echo "Error: Analysis not found at $ANALYSIS_FILE"
        echo "Run 'gh pr-enrich $ADDRESS_PR --enrich' first"
        exit 1
    fi

    # Validate JSON structure before use
    if ! jq -e '.task_list' "$ANALYSIS_FILE" > /dev/null 2>&1; then
        echo "Error: Analysis file is missing 'task_list' or contains invalid JSON"
        echo "File: $ANALYSIS_FILE"
        echo "Re-run: gh pr-enrich $ADDRESS_PR --enrich"
        exit 1
    fi

    # Get task count
    TASK_COUNT=$(jq '.task_list | length' "$ANALYSIS_FILE")
    if [ "$TASK_COUNT" -eq 0 ]; then
        echo "‚úÖ No tasks found in analysis. All done!"
        exit 0
    fi

    echo "üìã Found $TASK_COUNT tasks to address"
    echo ""

    CURRENT=0
    FIXED=0
    SKIPPED=0

    while [ $CURRENT -lt $TASK_COUNT ]; do
        TASK=$(jq -r ".task_list[$CURRENT]" "$ANALYSIS_FILE")
        PRIORITY=$(echo "$TASK" | jq -r '.priority')
        DESCRIPTION=$(echo "$TASK" | jq -r '.task')
        THREAD_IDS=$(echo "$TASK" | jq -r '.thread_ids | join(", ")')

        # Color based on priority
        case $PRIORITY in
            critical) PRIORITY_COLOR="\033[1;31m" ;;  # Bold red
            high)     PRIORITY_COLOR="\033[0;31m" ;;  # Red
            medium)   PRIORITY_COLOR="\033[0;33m" ;;  # Yellow
            low)      PRIORITY_COLOR="\033[0;32m" ;;  # Green
            *)        PRIORITY_COLOR="\033[0m" ;;
        esac

        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo -e "Task $((CURRENT + 1))/$TASK_COUNT [${PRIORITY_COLOR}${PRIORITY}\033[0m]"
        echo ""
        echo "$DESCRIPTION"
        echo ""
        if [ -n "$THREAD_IDS" ] && [ "$THREAD_IDS" != "null" ]; then
            echo "Threads: $THREAD_IDS"
        fi
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo -n "[f]ixed  [s]kip  [o]pen in browser  [q]uit > "

        read -r -n 1 ACTION
        echo ""

        case $ACTION in
            f|F)
                # Resolve all threads for this task (using parameterized query to prevent injection)
                THREAD_ARRAY=$(echo "$TASK" | jq -r '.thread_ids[]' 2>/dev/null)
                RESOLVE_FAILED=0
                if [ -n "$THREAD_ARRAY" ]; then
                    for TID in $THREAD_ARRAY; do
                        # Validate thread ID format before API call
                        if [[ ! "$TID" =~ ^PRRT_[A-Za-z0-9_-]+$ ]]; then
                            echo "  ‚ö†Ô∏è  Invalid thread ID format: $TID"
                            ((RESOLVE_FAILED++))
                            continue
                        fi
                        RESULT=$(gh api graphql \
                            -F threadId="$TID" \
                            -f query='mutation($threadId: ID!) {
                                resolveReviewThread(input: {threadId: $threadId}) {
                                    thread { isResolved }
                                }
                            }' 2>&1)
                        if echo "$RESULT" | jq -e '.data.resolveReviewThread.thread.isResolved' > /dev/null 2>&1; then
                            echo "  ‚úÖ Resolved: $TID"
                        else
                            ERROR=$(echo "$RESULT" | jq -r '.errors[0].message // "Unknown error"' 2>/dev/null || echo "$RESULT")
                            echo "  ‚ùå Failed to resolve $TID: $ERROR"
                            ((RESOLVE_FAILED++))
                        fi
                    done
                    if [ "$RESOLVE_FAILED" -gt 0 ]; then
                        echo "  ‚ö†Ô∏è  $RESOLVE_FAILED thread(s) failed to resolve - task may not be fully addressed"
                    fi
                fi
                ((FIXED++))
                ((CURRENT++))
                echo ""
                ;;
            s|S)
                echo "  ‚è≠Ô∏è  Skipped"
                ((SKIPPED++))
                ((CURRENT++))
                echo ""
                ;;
            o|O)
                # Get first thread URL
                FIRST_TID=$(echo "$TASK" | jq -r '.thread_ids[0] // empty')
                if [ -n "$FIRST_TID" ]; then
                    # Find URL in comment threads
                    THREAD_FILE=".reports/pr-reviews/pr-$ADDRESS_PR/comment-threads.json"
                    if [ -f "$THREAD_FILE" ]; then
                        URL=$(jq -r ".data.repository.pullRequest.reviewThreads.nodes[] | select(.id == \"$FIRST_TID\") | .comments.nodes[0].url // empty" "$THREAD_FILE")
                        if [ -n "$URL" ]; then
                            echo "  üåê Opening: $URL"
                            # Try macOS 'open', then Linux 'xdg-open'; Windows not supported
                            open "$URL" 2>/dev/null || xdg-open "$URL" 2>/dev/null || echo "  Could not open browser (try manually: $URL)"
                        else
                            echo "  Could not find URL for thread $FIRST_TID"
                        fi
                    else
                        echo "  Thread details file not found: $THREAD_FILE"
                        echo "  Re-run: gh pr-enrich $ADDRESS_PR to refresh data"
                    fi
                else
                    echo "  No thread ID associated with this task"
                fi
                # Don't advance - let user decide after viewing
                ;;
            q|Q)
                echo ""
                echo "Quitting..."
                break
                ;;
            *)
                echo "  Unknown action. Use f/s/o/q"
                ;;
        esac
    done

    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "Summary: $FIXED fixed, $SKIPPED skipped, $((TASK_COUNT - CURRENT)) remaining"
    exit 0
fi

# Handle --help flag
if [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ $# -lt 1 ]; then
    cat << 'HELP'
gh pr-enrich - Comprehensive PR analysis with optional Claude AI enrichment

USAGE:
  gh pr-enrich <PR_NUMBER> [OPTIONS]
  gh pr-enrich <SUBCOMMAND> [ARGS]

SUBCOMMANDS:
  install-skill       Install Claude Code skill (symlink to ~/.claude/skills/)
  uninstall-skill     Remove the Claude Code skill symlink
  resolve <ID...>     Resolve PR review threads by GraphQL ID
  watch <PR> [OPTS]   Monitor PR for new comments (--interval, --enrich, --notify)
  address <PR>        Interactive mode to work through issues one by one

OPTIONS:
  --json            Output only JSON (default: combined)
  --markdown        Output only Markdown (default: combined)
  --output-dir DIR  Directory to save output (default: .reports/pr-reviews/pr-<N>)
  --enrich          Run Claude AI analysis on unresolved comment threads
  --diff            Include code diffs in Claude context (richer analysis)
  --prompt FILE     Custom prompt file for Claude analysis (overrides defaults)
  -h, --help        Show this help message
  -v, --version     Show version

EXAMPLES:
  gh pr-enrich install-skill              # Install Claude Code skill
  gh pr-enrich 123                        # Basic PR report
  gh pr-enrich 123 --enrich               # With Claude AI analysis
  gh pr-enrich 123 --enrich --diff        # Analysis with code context
  gh pr-enrich 123 --output-dir ./pr      # Custom output directory
  gh pr-enrich 123 --json                 # JSON output only
  gh pr-enrich resolve PRRT_xxx PRRT_yyy  # Resolve multiple threads
  gh pr-enrich watch 123 --enrich         # Monitor and auto-analyze
  gh pr-enrich address 123                # Interactive issue fixing

PROMPT CUSTOMIZATION:
  The Claude analysis prompt is loaded from (in priority order):
  1. --prompt FILE argument
  2. GH_PR_ENRICH_PROMPT environment variable
  3. .gh-pr-enrich-prompt.txt in current directory
  4. default-prompt.txt bundled with extension

  See default-prompt.txt in the extension directory for format.

ENVIRONMENT VARIABLES:
  PR_REVIEW_OUTPUT_ROOT   Override default output directory root
  GH_PR_ENRICH_PROMPT     Path to custom prompt file for Claude analysis

DEPENDENCIES:
  Required: gh (GitHub CLI), jq
  Optional: claude (Claude CLI, for --enrich)

For more info: https://github.com/bl4ck3lk/gh-pr-enrich
HELP
    exit 0
fi

PR_NUMBER=$1

# Validate PR_NUMBER is a positive integer (prevent path traversal)
if ! [[ "$PR_NUMBER" =~ ^[0-9]+$ ]]; then
    echo "Error: PR_NUMBER must be a positive integer, got: '$PR_NUMBER'"
    exit 1
fi

shift
OUTPUT_FORMAT="combined"
DEFAULT_OUTPUT_ROOT="${PR_REVIEW_OUTPUT_ROOT:-.reports/pr-reviews}"
OUTPUT_DIR="$DEFAULT_OUTPUT_ROOT/pr-$PR_NUMBER"
CUSTOM_OUTPUT_DIR=false
ENRICH_WITH_CLAUDE=false
INCLUDE_DIFF=false
CUSTOM_PROMPT_FILE=""
REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || echo "current-repo")
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Get the directory where this extension is installed
get_extension_dir() {
    local script_path
    script_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    echo "$script_path"
}

# Load system prompt from file, filtering out comments
# Priority: --prompt arg > $GH_PR_ENRICH_PROMPT > .gh-pr-enrich-prompt.txt > default-prompt.txt
load_system_prompt() {
    local prompt_file=""
    local extension_dir
    extension_dir="$(get_extension_dir)"

    # Check --prompt argument first (highest priority)
    if [ -n "$CUSTOM_PROMPT_FILE" ] && [ -f "$CUSTOM_PROMPT_FILE" ]; then
        prompt_file="$CUSTOM_PROMPT_FILE"
    # Check environment variable
    elif [ -n "${GH_PR_ENRICH_PROMPT:-}" ] && [ -f "$GH_PR_ENRICH_PROMPT" ]; then
        prompt_file="$GH_PR_ENRICH_PROMPT"
    # Check for local repo override
    elif [ -f ".gh-pr-enrich-prompt.txt" ]; then
        prompt_file=".gh-pr-enrich-prompt.txt"
    # Fall back to bundled default
    elif [ -f "$extension_dir/default-prompt.txt" ]; then
        prompt_file="$extension_dir/default-prompt.txt"
    fi

    if [ -n "$prompt_file" ]; then
        # Filter out comment lines and leading blank lines (portable: works on BSD and GNU)
        grep -v '^#' "$prompt_file" | awk 'NF{found=1} found'
    else
        # Fallback if no file found (shouldn't happen normally)
        echo "You are a senior code reviewer analyzing unresolved PR comment threads.
Your task is to:
1. Categorize issues by type (security, performance, architecture, style, documentation, etc.)
2. Identify systemic patterns that appear across multiple comments
3. Suggest adjacent areas that may have similar problems worth investigating
4. Create a prioritized task list for addressing the issues

Focus on actionable insights. Be specific about file paths and patterns.
If there are no systemic issues or adjacent problems, return empty arrays for those fields."
    fi
}

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        --json)
            OUTPUT_FORMAT="json"
            shift
            ;;
        --markdown)
            OUTPUT_FORMAT="markdown"
            shift
            ;;
        --output-dir)
            if [ -z "${2:-}" ]; then
                echo "Error: --output-dir requires a directory path."
                exit 1
            fi
            CUSTOM_OUTPUT_DIR=true
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --enrich)
            ENRICH_WITH_CLAUDE=true
            shift
            ;;
        --diff)
            INCLUDE_DIFF=true
            shift
            ;;
        --prompt)
            if [ -z "${2:-}" ]; then
                echo "Error: --prompt requires a file path."
                exit 1
            fi
            if [ ! -f "$2" ]; then
                echo "Error: Prompt file not found: $2"
                exit 1
            fi
            CUSTOM_PROMPT_FILE="$2"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run 'gh pr-enrich --help' for usage"
            exit 1
            ;;
    esac
done

# Ensure jq is available
if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed."
    echo "Install with: brew install jq (macOS) or apt-get install jq (Linux)"
    exit 1
fi

# Check Claude CLI if enrichment requested (warn but don't fail)
if [ "$ENRICH_WITH_CLAUDE" = true ]; then
    if ! command -v claude &> /dev/null; then
        echo "Warning: Claude CLI not found. Skipping enrichment."
        echo "Install from: https://claude.ai/code"
        ENRICH_WITH_CLAUDE=false
    fi
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"

echo "Fetching details for PR #$PR_NUMBER in $REPO..."
echo "Saving report to: $OUTPUT_DIR"

# 1. Fetch PR summary
echo "Fetching PR summary..."
PR_SUMMARY_FIELDS="number,title,body,author,state,url,createdAt,updatedAt,mergedAt,closedAt,labels,assignees,reviewRequests,reviews,milestone,projectCards,additions,deletions,changedFiles,mergeable,isDraft,headRefName,headRefOid,baseRefName,baseRefOid,headRepository,headRepositoryOwner,files,commits,statusCheckRollup"
gh pr view "$PR_NUMBER" --json "$PR_SUMMARY_FIELDS" \
    > "$OUTPUT_DIR/pr-summary.json" 2>/dev/null || {
        echo "Error fetching PR summary. Ensure PR #$PR_NUMBER exists and you have access."
        exit 1
    }

# 2. Fetch all comments
echo "Fetching all comments..."
gh api --paginate "repos/$REPO/issues/$PR_NUMBER/comments" \
    | jq -s 'map(select(type == "array")) | (if length == 0 then [] else add end) | map(select(type == "object")) | map({
        id: .id,
        body: (.body // ""),
        user: .user.login,
        created_at: .created_at,
        updated_at: .updated_at,
        type: "issue_comment",
        html_url: .html_url
    })' > "$OUTPUT_DIR/issue-comments.json"

gh api --paginate "repos/$REPO/pulls/$PR_NUMBER/reviews" \
    | jq -s 'map(select(type == "array")) | (if length == 0 then [] else add end) | map(select(type == "object")) | map({
        id: .id,
        body: (.body // ""),
        user: .user.login,
        state: .state,
        submitted_at: .submitted_at,
        type: "review_comment",
        commit_id: .commit_id,
        html_url: .html_url
    })' > "$OUTPUT_DIR/review-comments.json"

gh api --paginate "repos/$REPO/pulls/$PR_NUMBER/comments" \
    | jq -s 'map(select(type == "array")) | (if length == 0 then [] else add end) | map(select(type == "object")) | map({
        id: .id,
        body: (.body // ""),
        path: .path,
        position: .position,
        line: .original_line,
        user: .user.login,
        created_at: .created_at,
        updated_at: .updated_at,
        type: "inline_comment",
        html_url: .html_url
    })' > "$OUTPUT_DIR/inline-comments.json"

# 3. Fetch comment threads with GraphQL IDs
echo "Fetching comment threads with GraphQL IDs..."
OWNER=$(echo "$REPO" | cut -d'/' -f1)
REPO_NAME=$(echo "$REPO" | cut -d'/' -f2)

GRAPHQL_QUERY='
query($owner: String!, $name: String!, $prNumber: Int!) {
  repository(owner: $owner, name: $name) {
    pullRequest(number: $prNumber) {
      reviewThreads(last: 100) {
        nodes {
          id
          isResolved
          comments(first: 10) {
            nodes {
              id
              databaseId
              body
              author {
                login
              }
              createdAt
              url
            }
          }
        }
      }
    }
  }
}
'

gh api graphql -F owner="$OWNER" -F name="$REPO_NAME" -F prNumber="$PR_NUMBER" -f query="$GRAPHQL_QUERY" \
    > "$OUTPUT_DIR/comment-threads.json" 2>/dev/null || {
        echo "Note: Could not fetch comment threads with GraphQL IDs."
        echo '{"data": {"repository": {"pullRequest": {"reviewThreads": {"nodes": []}}}}}' > "$OUTPUT_DIR/comment-threads.json"
    }

# Process comment threads to create ID mapping
jq -r '.data.repository.pullRequest.reviewThreads.nodes[] |
    select(.comments.nodes | length > 0) |
    .comments.nodes[] |
    select(.databaseId != null) |
    "\(.databaseId):\(.id)"' "$OUTPUT_DIR/comment-threads.json" > "$OUTPUT_DIR/id-mapping.txt" 2>/dev/null || {
        echo "" > "$OUTPUT_DIR/id-mapping.txt"
    }

# Function to add GraphQL IDs to comments
create_comments_with_graphql_ids() {
    local input_file="$1"
    local output_file="$2"
    local comment_type="$3"

    jq --rawfile id_map "$OUTPUT_DIR/id-mapping.txt" '
        map(. as $comment |
            . + {
                graphql_id: (
                    if ($comment.id and ($comment.id | type == "number")) then
                        ($id_map | split("\n") | map(select(length > 0) | split(":")) | map({key: .[0], value: .[1]}) | from_entries | .[$comment.id|tostring])
                    else
                        null
                    end
                ),
                comment_type: $comment_type
            }
        )
    ' "$input_file" --arg comment_type "$comment_type" > "$output_file"
}

# ============================================================================
# Claude Enrichment Functions
# ============================================================================

extract_unresolved_threads() {
    local threads_file="$1"
    local output_file="$2"

    jq '[.data.repository.pullRequest.reviewThreads.nodes[]
        | select(.isResolved == false)
        | {
            thread_id: .id,
            comments: [.comments.nodes[] | {
                author: (.author.login // "unknown"),
                body: .body,
                url: .url
            }]
        }]' "$threads_file" > "$output_file"
}

# Fetch the PR diff and create both raw and structured versions
# Args:
#   $1 - output_dir: Directory to save diff files
#   $2 - pr_num: PR number to fetch diff for
# Creates:
#   pr-diff.txt - Raw unified diff
#   pr-diff.json - Structured diff with file-level separation
fetch_pr_diff() {
    local output_dir="$1"
    local pr_num="$2"

    # Fetch the unified diff for the PR
    if ! gh pr diff "$pr_num" > "$output_dir/pr-diff.txt" 2>/dev/null; then
        echo "‚ö†Ô∏è  Could not fetch PR diff (binary files only, empty PR, or access denied)"
        echo "   Analysis will proceed without code context."
        echo "" > "$output_dir/pr-diff.txt"
    fi

    # Also create a structured version with file-level diffs
    # Truncate large diffs to avoid token limits in Claude API
    # 5000 chars per file balances context richness with API constraints
    jq -n --arg diff "$(<"$output_dir/pr-diff.txt")" \
        '{
            raw_diff: $diff,
            file_diffs: ($diff | split("diff --git ") | .[1:] | map(
                . as $chunk |
                ($chunk | split("\n") | .[0] | split(" ") | .[-1] | ltrimstr("b/")) as $filepath |
                {
                    file: $filepath,
                    content: ("diff --git " + $chunk)
                }
            ))
        }' > "$output_dir/pr-diff.json" 2>/dev/null || {
            echo '{"raw_diff": "", "file_diffs": []}' > "$output_dir/pr-diff.json"
        }
}

build_claude_context() {
    local output_dir="$1"
    local include_diff="${2:-false}"

    if [ "$include_diff" = "true" ] && [ -f "$output_dir/pr-diff.json" ]; then
        # Include diff in context for richer analysis
        jq -n \
            --argjson pr "$(<"$output_dir/pr-summary.json")" \
            --argjson unresolved "$(<"$output_dir/unresolved-threads.json")" \
            --argjson diff "$(<"$output_dir/pr-diff.json")" \
            '{
                pr: {
                    title: $pr.title,
                    body: ($pr.body // "No description"),
                    author: $pr.author.login,
                    files_changed: [$pr.files[].path]
                },
                unresolved_threads: $unresolved,
                code_changes: {
                    summary: "Diff included for context. Each file_diff contains the actual code changes.",
                    file_diffs: ($diff.file_diffs | map({
                        file: .file,
                        diff: (if (.content | length) > 5000 then
                            (.content | .[0:5000] + "\n... (truncated)")
                        else
                            .content
                        end)
                    }))
                }
            }' > "$output_dir/claude-context.json"
    else
        jq -n \
            --argjson pr "$(<"$output_dir/pr-summary.json")" \
            --argjson unresolved "$(<"$output_dir/unresolved-threads.json")" \
            '{
                pr: {
                    title: $pr.title,
                    body: ($pr.body // "No description"),
                    author: $pr.author.login,
                    files_changed: [$pr.files[].path]
                },
                unresolved_threads: $unresolved
            }' > "$output_dir/claude-context.json"
    fi
}

CLAUDE_ANALYSIS_SCHEMA='{
  "type": "object",
  "properties": {
    "issue_categories": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": { "type": "string" },
          "severity": { "enum": ["critical", "high", "medium", "low"] },
          "description": { "type": "string" },
          "thread_ids": { "type": "array", "items": { "type": "string" } }
        },
        "required": ["name", "severity", "description", "thread_ids"]
      }
    },
    "systemic_issues": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "pattern": { "type": "string" },
          "evidence": { "type": "array", "items": { "type": "string" } },
          "recommendation": { "type": "string" }
        },
        "required": ["pattern", "evidence", "recommendation"]
      }
    },
    "adjacent_problems": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "area": { "type": "string" },
          "risk": { "type": "string" },
          "investigation_hint": { "type": "string" }
        },
        "required": ["area", "risk", "investigation_hint"]
      }
    },
    "task_list": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "priority": { "enum": ["critical", "high", "medium", "low"] },
          "task": { "type": "string" },
          "thread_ids": { "type": "array", "items": { "type": "string" } }
        },
        "required": ["priority", "task", "thread_ids"]
      }
    },
    "process_improvements": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "category": { "enum": ["documentation", "automation", "testing", "review_process", "tooling"] },
          "suggestion": { "type": "string" },
          "rationale": { "type": "string" },
          "implementation_hint": { "type": "string" }
        },
        "required": ["category", "suggestion", "rationale"]
      }
    },
    "pr_template_suggestions": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "section": { "type": "string" },
          "checkbox_or_question": { "type": "string" },
          "why": { "type": "string" }
        },
        "required": ["section", "checkbox_or_question", "why"]
      }
    }
  },
  "required": ["issue_categories", "systemic_issues", "adjacent_problems", "task_list", "process_improvements", "pr_template_suggestions"]
}'

run_claude_analysis() {
    local context_file="$1"
    local output_file="$2"

    # Load system prompt from configurable file
    local system_prompt
    system_prompt="$(load_system_prompt)"

    local user_prompt="Analyze these unresolved PR comment threads and provide structured analysis:

$(cat "$context_file")"

    claude --print \
        --model sonnet \
        --output-format json \
        --json-schema "$CLAUDE_ANALYSIS_SCHEMA" \
        --system-prompt "$system_prompt" \
        "$user_prompt" > "$output_file" 2>/dev/null

    return $?
}

generate_analysis_report() {
    local analysis_file="$1"
    local output_file="$2"

    jq -r '
    "# ü§ñ Claude Analysis Report\n\n" +
    "## Issue Categories\n\n" +
    (if (.issue_categories | length) == 0 then
        "_No issue categories identified._\n\n"
    else
        (.issue_categories | map(
            "### " + .name + " (" + .severity + ")\n" +
            .description + "\n\n" +
            "**Threads:** " + (if (.thread_ids | length) > 0 then (.thread_ids | join(", ")) else "N/A" end) + "\n"
        ) | join("\n"))
    end) +
    "\n## Systemic Issues\n\n" +
    (if (.systemic_issues | length) == 0 then
        "_No systemic patterns identified._\n\n"
    else
        (.systemic_issues | map(
            "### " + .pattern + "\n\n" +
            "**Evidence:**\n" + (.evidence | map("- " + .) | join("\n")) + "\n\n" +
            "**Recommendation:** " + .recommendation + "\n"
        ) | join("\n"))
    end) +
    "\n## Adjacent Problems to Investigate\n\n" +
    (if (.adjacent_problems | length) == 0 then
        "_No adjacent problem areas identified._\n"
    else
        (.adjacent_problems | map(
            "- **" + .area + "** (" + .risk + "): " + .investigation_hint
        ) | join("\n"))
    end) +
    "\n\n## Task List\n\n" +
    (if (.task_list | length) == 0 then
        "_No tasks generated._\n"
    else
        (.task_list | map(
            "- [" + .priority + "] " + .task +
            (if (.thread_ids | length) > 0 then " _(threads: " + (.thread_ids | join(", ")) + ")_" else "" end)
        ) | join("\n"))
    end) +
    "\n\n## Process Improvements\n\n" +
    "_Suggestions to prevent similar issues in future PRs:_\n\n" +
    (if (.process_improvements | length) == 0 then
        "_No process improvements suggested._\n"
    else
        (.process_improvements | map(
            "### " + .suggestion + "\n" +
            "**Category:** " + .category + "\n\n" +
            .rationale + "\n" +
            (if .implementation_hint then "\n**How to implement:** " + .implementation_hint + "\n" else "" end)
        ) | join("\n"))
    end) +
    "\n\n## PR Template Suggestions\n\n" +
    "_Additions to the PR template that would catch these issues earlier:_\n\n" +
    (if (.pr_template_suggestions | length) == 0 then
        "_No PR template changes suggested._\n"
    else
        (.pr_template_suggestions | map(
            "### " + .section + "\n" +
            "```\n" + .checkbox_or_question + "\n```\n" +
            "_Why:_ " + .why + "\n"
        ) | join("\n"))
    end)
    ' "$analysis_file" > "$output_file"
}

# ============================================================================
# Main Processing
# ============================================================================

# Add GraphQL IDs to all comment types
create_comments_with_graphql_ids "$OUTPUT_DIR/issue-comments.json" "$OUTPUT_DIR/issue-comments-with-graphql.json" "issue_comment"
create_comments_with_graphql_ids "$OUTPUT_DIR/review-comments.json" "$OUTPUT_DIR/review-comments-with-graphql.json" "review_comment"
create_comments_with_graphql_ids "$OUTPUT_DIR/inline-comments.json" "$OUTPUT_DIR/inline-comments-with-graphql.json" "inline_comment"

# Combine comments
jq -s 'add | sort_by(.created_at // .submitted_at // "")' \
    "$OUTPUT_DIR"/issue-comments-with-graphql.json \
    "$OUTPUT_DIR"/review-comments-with-graphql.json \
    "$OUTPUT_DIR"/inline-comments-with-graphql.json \
    > "$OUTPUT_DIR/all-comments-with-graphql.json"

jq -s 'add | sort_by(.created_at // .submitted_at // "")' \
    "$OUTPUT_DIR"/issue-comments.json \
    "$OUTPUT_DIR"/review-comments.json \
    "$OUTPUT_DIR"/inline-comments.json \
    > "$OUTPUT_DIR/all-comments.json"

# 4. Fetch checks and status
echo "Fetching checks and status..."
gh pr checks "$PR_NUMBER" --json checkRuns,statusCheckRollup,statuses > "$OUTPUT_DIR/checks.json" 2>/dev/null || {
    echo "Note: Could not fetch checks (may require additional permissions)."
    echo '{}' > "$OUTPUT_DIR/checks.json"
}

# 5. Generate statistics
echo "Generating statistics..."

COMMENT_STATS=$(jq -n \
    --argjson comments "$(cat "$OUTPUT_DIR/all-comments.json")" \
    '{
        total: ($comments | length),
        by_type: ($comments | group_by(.type) | map({type: .[0].type, count: length})),
        by_user: ($comments | group_by(.user) | map({user: .[0].user, count: length}) | sort_by(-.count) | .[0:10]),
        recent: ($comments | sort_by(.created_at) | reverse | .[0:5])
    }')

CHECKS_STATS=$(jq -r '.statusCheckRollup | {
    overall_state: .state,
    conclusion: .conclusion,
    contexts: (.contexts | length),
    passing: (.contexts | map(select(.state == "success")) | length),
    failing: (.contexts | map(select(.state == "failure")) | length),
    pending: (.contexts | map(select(.state == "pending")) | length)
}' "$OUTPUT_DIR/checks.json" 2>/dev/null || echo '{"overall_state": "unknown"}')

# 6. Create combined JSON
echo "Creating combined JSON..."
jq -n \
    --argjson summary "$(<"$OUTPUT_DIR/pr-summary.json")" \
    --argjson comments "$(<"$OUTPUT_DIR/all-comments-with-graphql.json")" \
    --argjson checks "$(<"$OUTPUT_DIR/checks.json")" \
    --argjson comment_stats "$COMMENT_STATS" \
    --argjson checks_stats "$CHECKS_STATS" \
    --argjson comment_threads "$(<"$OUTPUT_DIR/comment-threads.json")" \
    --arg timestamp "$TIMESTAMP" \
    --arg repo "$REPO" \
    '{
        metadata: {
            generated_at: $timestamp,
            repository: $repo,
            pr_number: ($summary.number | tonumber)
        },
        pr: $summary,
        comments: $comments,
        comment_threads: $comment_threads,
        checks: $checks,
        statistics: {
            comments: $comment_stats,
            checks: $checks_stats
        }
    }' > "$OUTPUT_DIR/combined-data.json"

# 7. Create Markdown report
echo "Creating Markdown report..."
cat > "$OUTPUT_DIR/comprehensive-report.md" << EOF
# Comprehensive PR Review Report: #$PR_NUMBER

**Repository:** $REPO
**Generated:** $TIMESTAMP
**PR URL:** $(jq -r '.url' "$OUTPUT_DIR/pr-summary.json")

## üìã PR Summary

**Title:** $(jq -r '.title' "$OUTPUT_DIR/pr-summary.json")
**Author:** $(jq -r '.author.login' "$OUTPUT_DIR/pr-summary.json")
**State:** $(jq -r '.state' "$OUTPUT_DIR/pr-summary.json")
**Created:** $(jq -r '.createdAt' "$OUTPUT_DIR/pr-summary.json")
**Updated:** $(jq -r '.updatedAt' "$OUTPUT_DIR/pr-summary.json")
**Mergeable:** $(jq -r '.mergeable' "$OUTPUT_DIR/pr-summary.json")
**Draft:** $(jq -r '.isDraft' "$OUTPUT_DIR/pr-summary.json")

**Changes:**
- Files: $(jq -r '.changedFiles' "$OUTPUT_DIR/pr-summary.json")
- Additions: $(jq -r '.additions' "$OUTPUT_DIR/pr-summary.json")
- Deletions: $(jq -r '.deletions' "$OUTPUT_DIR/pr-summary.json")

**Labels:** $(jq -r '.labels[]?.name // empty' "$OUTPUT_DIR/pr-summary.json" | tr '\n' ', ' | sed 's/,$//')
**Assignees:** $(jq -r '.assignees[]?.login // empty' "$OUTPUT_DIR/pr-summary.json" | tr '\n' ', ' | sed 's/,$//')
**Reviewers:** $(jq -r '.requestedReviewers[]?.login // empty' "$OUTPUT_DIR/pr-summary.json" | tr '\n' ', ' | sed 's/,$//')

### Files Changed
$(jq -r '.files[] | "- **\(.path)** (+\(.additions) / -\(.deletions))"' "$OUTPUT_DIR/pr-summary.json")

## ‚úÖ Checks & Status

**Overall State:** $(jq -r '.statusCheckRollup.state // "unknown"' "$OUTPUT_DIR/checks.json")
**Conclusion:** $(jq -r '.statusCheckRollup.conclusion // "N/A"' "$OUTPUT_DIR/checks.json")

## üí¨ Comments Analysis

$(echo "$COMMENT_STATS" | jq -r '
"**Total Comments:** " + ((.total // 0) | tostring) + "\n\n" +
"### By Type\n" + ((.by_type // []) | map("- **" + (.type // "unknown") + ":** " + ((.count // 0) | tostring)) | join("\n")) + "\n\n" +
"### Top Commenters\n" + ((.by_user // []) | map("- **" + (.user // "unknown") + ":** " + ((.count // 0) | tostring)) | join("\n"))
')

## üßµ Comment Threads

To resolve a comment thread:
\`\`\`bash
gh api graphql -f query='mutation { resolveReviewThread(input: {threadId: "<THREAD_ID>"}) { thread { isResolved } } }'
\`\`\`

---

*Report generated by gh-pr-enrich v$VERSION at $TIMESTAMP*
EOF

# 8. Optional: Claude enrichment
if [ "$ENRICH_WITH_CLAUDE" = true ]; then
    echo "Running Claude analysis on unresolved threads..."

    extract_unresolved_threads "$OUTPUT_DIR/comment-threads.json" "$OUTPUT_DIR/unresolved-threads.json"

    UNRESOLVED_COUNT=$(jq 'length' "$OUTPUT_DIR/unresolved-threads.json")

    if [ "$UNRESOLVED_COUNT" -gt 0 ]; then
        echo "Found $UNRESOLVED_COUNT unresolved thread(s). Analyzing with Claude Sonnet..."

        # Fetch diff if requested
        if [ "$INCLUDE_DIFF" = true ]; then
            echo "Fetching PR diff for richer context..."
            fetch_pr_diff "$OUTPUT_DIR" "$PR_NUMBER"
        fi

        build_claude_context "$OUTPUT_DIR" "$INCLUDE_DIFF"

        if run_claude_analysis "$OUTPUT_DIR/claude-context.json" "$OUTPUT_DIR/claude-raw-response.json"; then
            echo "‚úÖ Claude analysis complete"

            if jq -e '.structured_output' "$OUTPUT_DIR/claude-raw-response.json" > /dev/null 2>&1; then
                jq '.structured_output' "$OUTPUT_DIR/claude-raw-response.json" > "$OUTPUT_DIR/claude-analysis.json"
            else
                cp "$OUTPUT_DIR/claude-raw-response.json" "$OUTPUT_DIR/claude-analysis.json"
            fi

            generate_analysis_report "$OUTPUT_DIR/claude-analysis.json" "$OUTPUT_DIR/claude-analysis.md"

            jq --argjson analysis "$(<"$OUTPUT_DIR/claude-analysis.json")" \
               '. + {claude_analysis: $analysis}' \
               "$OUTPUT_DIR/combined-data.json" > "$OUTPUT_DIR/combined-data.tmp.json" && \
               mv "$OUTPUT_DIR/combined-data.tmp.json" "$OUTPUT_DIR/combined-data.json"

            cat >> "$OUTPUT_DIR/comprehensive-report.md" << 'ANALYSIS_SECTION'

---

ANALYSIS_SECTION
            cat "$OUTPUT_DIR/claude-analysis.md" >> "$OUTPUT_DIR/comprehensive-report.md"
        else
            echo "‚ö†Ô∏è  Claude analysis failed. Continuing without enrichment."
        fi
    else
        echo "No unresolved threads found. Skipping Claude analysis."
    fi
fi

# Output
case $OUTPUT_FORMAT in
    "json")
        cat "$OUTPUT_DIR/combined-data.json"
        ;;
    "markdown")
        cat "$OUTPUT_DIR/comprehensive-report.md"
        ;;
    "combined")
        echo "‚úÖ Report generated successfully!"
        echo "üìÅ Directory: $OUTPUT_DIR"
        echo "üìä Markdown: $OUTPUT_DIR/comprehensive-report.md"
        echo "ü§ñ JSON: $OUTPUT_DIR/combined-data.json"
        if [ -f "$OUTPUT_DIR/claude-analysis.json" ]; then
            echo "üß† Claude Analysis: $OUTPUT_DIR/claude-analysis.md"
        fi
        ;;
esac
